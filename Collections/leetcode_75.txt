// leetcode - 1768 MERGE STRING ALTERNATIVELY
class Solution {
    public String mergeAlternately(String word1, String word2) {

        char[] a = word1.toCharArray();
        char[] b = word2.toCharArray();

        char[] result = new char[word1.length() + word2.length()];
        
        int i = 0; int j = 0; int k = 0;

        while(i<word1.length() && j<word2.length()){

         result[k++] = a[i++];
         result[k++] = b[j++];
        }

        while(i < word1.length()){
            result[k++] = a[i++];
        }

        while(j < word2.length()){
            result[k++] = b[j++];
        }
        
        String merged = "";
        for(int m = 0;m<result.length;m++){
            merged += result[m];
        }
        return merged;
    }
}

// find gcd

int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

// leetcode 1071 - GREATEST COMMON DIVISOR OF STRINGS

class Solution {
    public String gcdOfStrings(String str1, String str2) {

        if(!(str1+str2).equals(str2+str1)){
            return "";
        }

        int gcdLength = gcd(str1.length(), str2.length());
        return str1.substring(0,gcdLength);

    }
        int gcd(int a, int b){
            if(b==0){ return a; }
            return gcd(b, a%b);
        
    }
}

//1431 - GREATEST NO OF CANDIES

 class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        
        int max = 0;
        
        for(int candy : candies){
            if(candy > max){
                max = candy;
            }
        }

        List<Boolean> result = new ArrayList<>();

        for(int i=0;i<candies.length;i++){
           int total = candies[i] + extraCandies;
            if(total >= max){
                result.add(true);
            }
            else{
                result.add(false);
            }
        }
        return result;
    }
}

//leetcode - 605 CAN PLACE FLOWERS

class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        
        if(flowerbed.length<=1){
            if(n==0){
                return true;
            }
        }
        
        int count  = 0;
        int i = 0;

        while(i<flowerbed.length){

            if(flowerbed[i]==0){
                int left = (i==0) ? 0 : flowerbed[i-1];
                int right = (i==flowerbed.length-1) ? 0 : flowerbed[i+1];     

            if(left == 0 && right==0){
                flowerbed[i] = 1;
                count++;        
            }
              if(count >= n){
                return true;}

            }
            i++;
        }
        return false;
    }
}


